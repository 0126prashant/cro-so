
const urlParams = new URLSearchParams(window.location.search);
console.log("urlParams",urlParams);
const creatorID = urlParams.get('creatorID');

console.log("Creator ID in new tab:", creatorID);
fetch(`/pdffeedback/${creatorID}`)
  .then((response) => {
    if (response.ok) {
      return response.json();
    } else {
      throw new Error("Error fetching data");
    }
  })
  .then((data) => {
    console.log(data);
    Display(data);
  })
  .catch((error) => {
    console.error("Error fetching data:", error);
  });



function imageUrlToBase64(url, callback) {
  fetch(url, {
    method: "GET",
    mode: "cors",
  })
    .then((response) => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.blob();
    })
    .then((blob) => {
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      reader.onloadend = () => {
        const base64data = reader.result;
        callback(base64data);
      };
    })
    .catch((error) => {
      console.error("Error fetching or encoding image:", error);
      callback(null);
    });
}

const main = document.getElementById("dynamic-part");


function generatePdfWithJSPDF() {
  const ele = document.getElementById("hello");
  const options = {
    margin: [10, 10, 10, 10],
    filename: "pdf_file.pdf",
    image: { type: "jpeg", quality: 0.98 },
    jsPDF: { unit: "pt", format: "a4", orientation: "portrait" },
  };

  html2pdf()
    .set(options)
    .from(ele)
    .toPdf()
    .output("blob")
    .then(function (pdfBlob) {
      const formData = new FormData();
      formData.append("creatorID", creatorID);
      formData.append("pdf", pdfBlob, "pdf_file.pdf");

      fetch("/upload-pdf", {
        method: "POST",
        body: formData,
      })
        .then((response) => response.json())
        .then((data) => {
          console.log("PDF uploaded successfully:", data);
        })
        .catch((error) => {
          console.error("Error uploading PDF:", error);
        });
    });
}

function generateFooter() {
  let footerContainer = document.createElement("div");
  let innerContainer = document.createElement("div");
  let generatedByText = document.createElement("p");
  let logoImage = document.createElement("img");

  footerContainer.className = "footer-mudcy";
  footerContainer.setAttribute(
    "style",
    `
        display: flex;
        justify-content: flex-end;
        border: 2px solid;
        border-top: none;
        border-bottom: none;
        border-left: none;
        border-right: none;
        background-color: #e8fc00;`
  );

  innerContainer.setAttribute(
    "style",
    `
        display: flex;
        align-items: center;
        height:40px`
  );

  generatedByText.innerHTML = "Generated by";
  generatedByText.setAttribute(
    "style",
    `
        margin-right: 10px;
        margin-top: 25px;`
  );

  logoImage.src = "./assets/muducy-logo.png";
  logoImage.alt = "Error in Muducy";
  logoImage.setAttribute(
    "style",
    `
        height: 40px;
        width: auto;`
  );
  innerContainer.append(generatedByText, logoImage);
  footerContainer.append(innerContainer);

  return footerContainer;
}

function Display(data) {
  // Function to append CRO feedback
  const appendCROFeedback = (parentElement, item, isMobile = false) => {
    const feedbackDiv = document.createElement("div");
    feedbackDiv.classList.add(isMobile ? "mobileFeedback" : "desktopFeedback");
    feedbackDiv.style.width = isMobile ? "50%" : "100%";
    // feedbackDiv.style.border = "2px solid green";
    feedbackDiv.style.display = isMobile ? "inline-block" : "block";

    let feedbackContent = "";
      for (let i = 1; i <= Object.keys(item.cro_feedback).length / 2; i++) {
        if (item.cro_feedback[`advice_heading_${i}`] && item.cro_feedback[`advice_${i}`]) {
          feedbackContent += `
            <div class="feedbackItem">
              <span class="feedbackNumber">${i}</span>
              <div class="feedbackContent">
                <div class="feedbackHeading">${item.cro_feedback[`advice_heading_${i}`]}</div>
                <div>${item.cro_feedback[`advice_${i}`]}</div>
              </div>
            </div>
          `;
        }
      }
      if (item.cro_feedback.super_cro_tip_advice) {
        feedbackContent += `<div class="superCROTip">Super CRO Tip: ${item.cro_feedback.super_cro_tip_advice}</div>`;
      }

    feedbackDiv.innerHTML = feedbackContent;
    parentElement.appendChild(feedbackDiv);
  };
  function createItemDisplay(item, isMobile, alignLeft = false) {
    const itemParentDiv = document.createElement("div");
    itemParentDiv.classList.add(isMobile ? "mobileParentDiv" : "desktopParentDiv");
    itemParentDiv.style.display = "flex";
    itemParentDiv.style.flexDirection = isMobile ? (alignLeft ? "row-reverse" : "row") : "column";
    itemParentDiv.style.justifyContent = isMobile && alignLeft ? "flex-end" : "flex-start";
    // itemParentDiv.style.border = "2px solid";
    itemParentDiv.style.width = "100%";

    const itemImage = document.createElement("img");
    itemImage.style.width = isMobile ? "40%" : "100%";
    itemImage.style.height = isMobile ? "400px" : "300px";
    itemImage.style.border = "2px solid";
    itemImage.src = item.image_url;
    itemParentDiv.appendChild(itemImage);

    appendCROFeedback(itemParentDiv, item, isMobile);

    return itemParentDiv;
  }
  const desktopData = data.filter(item => item.device === "desktop");
  const mobileData = data.filter(item => item.device === "mobile");
  const itemPromises = desktopData.map((desktopItem, index) => {
    return new Promise((resolve) => {
      const parentDiv = document.createElement("div");
      parentDiv.classList.add("parentDiv");
      parentDiv.style.border = "2px solid";
      parentDiv.style.width = "100%";
      parentDiv.style.marginTop = "50px";
      parentDiv.appendChild(createItemDisplay(desktopItem, false));
      if (index < mobileData.length) {
        parentDiv.appendChild(createItemDisplay(mobileData[index], true));
      }
      parentDiv.appendChild(generateFooter());
      main.appendChild(parentDiv);

      resolve()
    });
  });
  if (mobileData.length > desktopData.length) {
    let alignLeft = false;
    for (let i = desktopData.length; i < mobileData.length; i++) {
      itemPromises.push(new Promise((resolve) => {
        const parentDiv = document.createElement("div");
        parentDiv.classList.add("parentDiv");
        parentDiv.style.border = "2px solid";
        parentDiv.style.width = "100%";
        parentDiv.appendChild(createItemDisplay(mobileData[i], true, alignLeft));
        alignLeft = !alignLeft;
        parentDiv.appendChild(generateFooter());
        main.appendChild(parentDiv);

        resolve(); 
      }));
    }
  }
  Promise.all(itemPromises)
    .then(() => {
      setTimeout(() => {
        generatePdfWithJSPDF();
      }, 2000);
    })
    .catch((error) => {
      console.error("Error generating dynamic content:", error);
    });
}





document.addEventListener("DOMContentLoaded", function () {
  var downloadBtn = document.getElementById("download-btn");

  if (!downloadBtn.dataset.listenerAdded) {
    downloadBtn.addEventListener("click", function (event) {
      console.log("Download button clicked");
      generatePdfWithJSPDF();
    });

    downloadBtn.dataset.listenerAdded = "true";
  }
});










